# Pico MIDI Transformer

This project provides examples of using a microcontroller with a
[RP2040](https://en.wikipedia.org/wiki/RP2040) (or RP2350) chip to convey MIDI
messages via USB, for example between MIDI devices and a computer. Although
it can pass through messages untouched, it can also transform these messages in
real time.

When its primary USB port is connected to a host, the controller will appear as
both a MIDI input and output. Anything send to the MIDI output are
transformed and passed along to the MIDI input.

The controller also acts as a USB host for devices connected to its secondary
USP port. Messages generated by client USB MIDI devices are transformed and
passed along to the MIDI input.

## But, Why?

Personally, I'm building this for my own reference in recreating many of the
WebMIDI examples on my [demo site](https://duhrer.github.io/demos/).

I'm also trying to provide a starting point for people building tiny connective
devices to change the behaviour of their MIDI devices, for example:

1. External arpeggiators, which play a series of notes when a single note is pressed.
2. External keyboard "splitters" that send notes from different key ranges to different channels.
3. Filters to limit which information can be passed back and forth (for example,
   to ignore that one pesky button on your controller that sends control code 7
   and mutes the volume).

## OK, How?

### Hardware Prerequisites

First, you'll need compatible hardware, which means a Pico or compatible unit
with two USB ports. The [Adafruit Feather RP2040 with USB Type A
Host](https://www.adafruit.com/product/5723) is a good example of a unit that
has the second USB port built-in. You can also bring your own Pico (or
Pico-compatible) and wire it up as described in the documentation for the [OGX
Mini project](https://github.com/wiredopposite/OGX-Mini).

### Software Prerequisites

Once you have something to run the code on, you'll need to set up a build
environment. In the past, I have used:

1. The [Getting Started with Pico Guide](https://datasheets.raspberrypi.org/pico/getting-started-with-pico.pdf)
2. The [Pico VS Code extension](https://github.com/raspberrypi/pico-vscode)

Both of those are probably the easiest starting points, and if you hit upon
questions, there are lots of people working with them, so hopefully you can find
the guidance you need.

Personally, I use [distrobox](https://distrobox.it/) and [the docker container
created by `lukstep`](https://github.com/lukstep/raspberry-pi-pico-docker-sdk),
which I set up using commands like:

```
distrobox-create --image lukstep/raspberry-pi-pico-sdk -n pico-sdk
distrobox enter pico-sdk
```

### Checking out the Code

This project uses [git
submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules) for the
libraries it relies on. This means that if you
[clone](https://git-scm.com/docs/git-clone) this repository, you won't have all
the code you need to successfully build binaries.

Although there are multiple ways to manage submodules, the simplest way to get
everything you need is to use a command like:

```
git clone --recurse-submodules https://github.com/duhrer/pico-midi-transformer.git
```

### Building

Once you have a working build environment, you should be able to build the code
in this project using commands like:

```
mkdir -p build
cd build
cmake ..
make -j8
```

You should end up with binaries in various formats.

### Installing

The simplest way to install a binary is to boot the microcontroller into
`bootsel` mode. Hold down the `bootsel` button and plug your microcontroller
into USB. A USB drive will appear, and you can copy one the
`pico-midi-transformer.uf2` file generated by the build process onto your unit.
It will process and install the binary if it can. If it doesn't do anything,
make sure you're building for the right processor family, and try other test
binaries, like the examples that come with [the Pico
SDK](https://github.com/raspberrypi/pico-sdk).

If you're lucky enough to have a board with a reset button, all of the binaries
in this project also support entering `bootsel` mode by pressing the reset
button twice. You then copy the `pico-midi-transformer.uf2` file to the USB
drive as described above.

If you have a [pico probe](https://www.raspberrypi.com/products/debug-probe/) or
other debugging unit, and if your microcontroller exposes the ports you need,
you can use `openocd` to deploy binaries. With this method, you deploy the
`pico-midi-transformer.elf` file generated during the build process. Check the
"Getting Started with Pico Guide" for more info.

### Trying it Out

This example is meant to be instructive, and not necessarily something you'll
use in a performance.  It:

1. Makes sure all messages are sent to channel 0.
2. Passes through all note messages.
3. Inverts the pitch bend and mod wheel.
4. Ignores all other messages.



## Making Your Own Thing Instead

There's a lot to learn here, but I kept this project as simple as I could to
give you a basic examples of:

1. Building and installing everything.
2. Bringing in the required [TinyUSB](https://github.com/hathach/tinyusb) and
   [Pico PIO USB](https://github.com/sekigon-gonnoc/Pico-PIO-USB) libraries.
3. Adding the configuration files and stub functions to enable TinyUSB to work.
4. Receiving, inspecting, constructing, and transmitting MIDI messages.

Feel free to fork/copy the work here and modify it to suit you (but do please
check out the [license terms](./LICENSE)).