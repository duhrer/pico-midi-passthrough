# Pico MIDI Passthrough

This project is intended to help people working with:

1. MIDI messages
2. Microcontollers that use the [RP2040](https://en.wikipedia.org/wiki/RP2040) (or RP2350) chip
3. [TinyUSB](https://github.com/hathach/tinyusb)
4. [PIO USB](https://github.com/sekigon-gonnoc/Pico-PIO-USB)

It passes messages received by the (PIO) "host" USB port to the "client" USB
port and vice versa. See "Actually Using It" below for more details.

This project was cloned from [my template
repository](https://github.com/duhrer/pico-midi-transformer), see that project
for more technical details and background information.

## Hardware Prerequisites

First, you'll need compatible hardware, which means a Pico or compatible unit
with two USB ports. The [Adafruit Feather RP2040 with USB Type A
Host](https://www.adafruit.com/product/5723) is a good example of a unit that
has the second USB port built-in.  There's also a [unit from
Waveshare](https://www.waveshare.com/wiki/RP2350-USB-A), which has an RP2350
chip instead.

You can also bring your own Pico (or Pico-compatible) and wire it up as
described in the documentation for the [OGX Mini
project](https://github.com/wiredopposite/OGX-Mini).

## Software Prerequisites

Once you have something to run the code on, you'll need to set up a build
environment. In the past, I have used:

1. The [Getting Started with Pico Guide](https://datasheets.raspberrypi.org/pico/getting-started-with-pico.pdf)
2. The [Pico VS Code extension](https://github.com/raspberrypi/pico-vscode)

Both of those are probably the easiest starting points, and if you hit upon
questions, there are lots of people working with them, so hopefully you can find
the guidance you need.

Personally, I use [distrobox](https://distrobox.it/) and [the docker container
created by `lukstep`](https://github.com/lukstep/raspberry-pi-pico-docker-sdk),
which I set up using commands like:

```
distrobox-create --image lukstep/raspberry-pi-pico-sdk -n pico-sdk
distrobox enter pico-sdk
```

## Checking out the Code

This project uses [git
submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules) for the
libraries it relies on. This means that if you
[clone](https://git-scm.com/docs/git-clone) this repository, you won't have all
the code you need to successfully build binaries.

Although there are multiple ways to manage submodules, the simplest way to get
everything you need is to use a command like:

```
git clone --recurse-submodules https://github.com/duhrer/pico-midi-passthrough.git
```

## Building

Once you have a working build environment, you should be able to build the code
in this project using commands like the following for RP2040 (Pico 1) units:

```
mkdir -p build
cd build
cmake ..
make -j16
```

For RP2350 (Pico 2) units, you need to pass a flag, as in:

```
mkdir -p build
cd build
cmake -DFAMILY=rp2350 ..
make -j16
```

You should end up with binaries in various formats.

## Installing

The simplest way to install a binary is to boot the microcontroller into
`bootsel` mode. Hold down the `bootsel` button and plug your microcontroller
into USB. A USB drive will appear, and you can copy one the
`pico-midi-transformer.uf2` file generated by the build process onto your unit.
It will process and install the binary if it can. If it doesn't do anything,
make sure you're building for the right processor family, and try other test
binaries, like the examples that come with [the Pico
SDK](https://github.com/raspberrypi/pico-sdk).

If you're lucky enough to have a board with a reset button, all of the binaries
in this project also support entering `bootsel` mode by pressing the reset
button twice. You then copy the `pico-midi-passthrough.uf2` file to the USB
drive as described above.

If you have a [pico probe](https://www.raspberrypi.com/products/debug-probe/) or
other debugging unit, and if your microcontroller exposes the ports you need,
you can use `openocd` to deploy binaries. With this method, you deploy the
`pico-midi-passthrough.elf` file generated during the build process. Check the
"Getting Started with Pico Guide" for more info.

## Actually Using It

### Testing Host -> Client

1. Hook something up to the "host" USB port on the microcontroller.
2. Connect something to the "client" side, for example a sound-producing program
   or a [MIDI monitor](https://studiocode.dev/midi-monitor/).
3. Send a message from the "host" side, for example by playing a note or
   changing a control.
4. Observe the results on the "client" side.

### Testing Client -> Host

1. Hook something up to the "host" USB port on the microcontroller, ideally
   something that you can tell is reacting to messages.
2. Connect something to the "client" side, for example, [this WebMIDI tester
   that can send any type of message](https://studiocode.dev/webmidi-tester/)
3. Send a message to the "client" side.
4. Observe the results on the "host" side.

### Debugging

By connecting a debugger to the microcontroller, you can set breakpoints and
observe processes like:

1. Receiving messages from the client side.
2. Sending messages to the client side.
3. Receiving messages from the host side.
4. Sending messages to the host side.
